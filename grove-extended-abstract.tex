\documentclass[nonacm, acmsmall, screen, review]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

\usepackage{stmaryrd}

\newcommand{\e}{\varepsilon}

\newcommand{\id}[1]{\textcolor{gray}{\ensuremath{#1}}}
\newcommand{\eid}[2]{{#2}^{\id{#1}}}

\newcommand{\hole}{\ensuremath{\square}} %\textcolor{violet}{\llparenthesis}}\textcolor{violet}{\rrparenthesis}}
\newcommand{\conflictHole}[1]{%
{\noexpandarg\StrSubstitute{#1}{,}{\textcolor{red}{\,\textbf{|}\,}}[\myargs]%
{\textcolor{red}{\textbf{\{}}\myargs\textcolor{red}{\textbf{\}}}}}}%
\newcommand{\emptyHole}[2]{\square_{\id{(#1, #2)}}}

\newcommand{\eVar}[2]{\eid{#1}{#2}}
\newcommand{\eFun}[4]{\eid{#1}{\lambda} #2 : #3 . #4}
\newcommand{\eApp}[3]{\eid{#1}{\left(#2~#3\right)}}
\newcommand{\eNum}[2]{\eid{#1}{\underline{#2}}}
\newcommand{\ePlus}[3]{#2~\eid{#1}{\texttt{+}}~#3}
\newcommand{\eTimes}[3]{#2~\eid{#1}{\texttt{*}}~#3}
\newcommand{\pVar}[2]{\eid{#1}{#2}}
\newcommand{\tArrow}[3]{#2 \eid{#1}{\rightarrow} #3}
\newcommand{\tNum}[1]{\eid{#1}{Num}}

\newcommand{\multiVertex}[1]{\textcolor{red}{\ensuremath{\curlyveedownarrow_{#1}}}}
\newcommand{\cycleVertex}[1]{\textcolor{red}{\ensuremath{\circlearrowleft_{#1}}}}

\newcommand{\kbinput}[1]{\texttt{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title[Grove]{Grove: A Convergent Collaborative Structure-Editor Calculus}

% \author{Michael D. Adams}
% \orcid{0000-0003-3160-6972}

\author{Eric Griffis}
\orcid{0000-0003-1693-6172}

% \author{Cyrus Omar}
% \orcid{0000-0003-4502-7971}
\affiliation{
  %\position{Assistant Research Scientist}
  \department[0]{Computer Science and Engineering}
  \department[1]{Electrical Engineering and Computer Science}
  \department[2]{College of Engineering}
  \institution{University of Michigan}
  \streetaddress{Bob and Betty Beyster Building, 2260 Hayward Street}
  \city{Ann Arbor}
  \state{MI}
  \postcode{48109-2121}
  \country{USA}
}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO: name-check Hazel and Scratch and MPS (and WebFlow)

\section{Introduction}

% (avoid creating a fight in the intro by claiming things the reader may summarily reject)

% (Cyrus: We use version control systems and we even use live share)
Programming is increasingly collaborative.
Programmers use a variety of tools, ranging from batch version control systems like Git~\cite{chacon_pro_2014} to real time collaboration tools such as Live Share~\cite{noauthor_use_nodate}, to coordinate changes to a common code base.

% (introduce structure editing)
% (Cyrus: in recent years, structure editing has been an active research area... talk about Hazel, Scratch, MPS, etc.
These collaboration tools largely assume that programs are edited as text.
However, structure editing has become increasingly prominent in both research and practice in recent years with tools like 
Scratch~\cite{resnick_scratch_2009}, 
MPS~\cite{voelter_language_2011}, 
Hazel~\cite{omar_hazelnut_2017}, 
WebFlow~\cite{noauthor_webflow_nodate},
and others.
%%% Make it clear this is something our community should care about
Structure editing makes (syntactically or semantically) invalid programs impossible to represent, which promises to simplifies the editing process for programmers at every skill level.

Existing collaboration techniques underlying tools such at Git or Live Share are text based.
Text editing involves linear edits, e.g., line or character insertions and deletions.
Structure editing, in contrast, involves tree edits, e.g., node insertions, deletions, and repositionings.
It is not clear how to generalize collaborative techniques rooted in text editing to a structured setting.
Our goal is to develop collaborative techniques that are rooted in structure editing.

% (Cyrus: Why is this a hard problem? All our existing tools are text based and it isn't clear how to do that correctly in a structured setting.)
In this paper, we introduce Grove, a \emph{collaborative structure editor calculus} based on Hazelnut~\cite{omar_hazelnut_2017}, a single-user structure editor calculus.
% (Introduce Grove: what makes it collaborative? what interesting thingG
In Grove, edits are commutative, i.e., they can be applied in any order, so collaboration is simply replay.
The shared edit state is represented as a graph, which is necessary to model interesting states that arise naturally in a collaborative setting, 
including direct conflicts and positioning conflicts. 
Users do not work with this graph directly---instead, the graph can be decomposed into a collection of syntax trees with references between them, which we call a \emph{grove}.
User actions on the grove can be converted into graph edits to be applied locally or sent to another user for replay.

% TODO: outline the rest of the paper

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Approach}

% starting
Suppose Alice and Bob want to collaboratively edit a program.
For our examples, the goal is to arrive at a simple arithmetic expression of initially indeterminate form.
Although we assume something like real-time synchronization,
neither this narrative nor the underlying technical development precludes a more traditional Git-style approach.

% sketch and share 
Upon opening their respective editors to a new shared program,
both Alice and Bob see a cursor on an empty hole ($\hole$).
Alice begins by constructing a number (1).
The new term ``fills'' the hole under the cursor by taking its place.
Bob continues to see the hole until he receives Alice's edit,
at which point he also see the number.

% wrapping
Bob builds on Alice's work by constructing a binary sum ($\ePlus{}{\hole}{\hole}$).
Because his cursor is on a concrete term (the number) instead of an empty hole, the existing term is ``wrapped'' by the new one.
Bob now sees a sum with the number on the left and an empty hole on the right ($\ePlus{}{1}{\hole}$).
Alice continues to see only the number until she receives Bob's edit,
at which point she also sees the sum.

% conflict
Next, Alice and Bob move their cursors to the empty hole on the right.
Unfortunately, they have not yet agreed on what the next edit will be.
Alice constructs a product ($\eTimes{}{\hole}{\hole}$),
whereas Bob constructs a variable ($x$).
They receive each other's edit at the same time, i.e., without any global relative ordering between the two edits.
Now, the right side of the sum has a conflict: is it a variable or a product?
This fact is explicitly represented as a conflict hole on the right side of the sum ($\ePlus{}{1}{\conflictHole{x, \eTimes{}{\hole}{\hole}}}$).

% deletion / detach
Bob moves his cursor to the variable and renames it to $y$.
Before Alice receives Bob's edit,
she decides to resolve the conflict by wrapping Bob's variable in the product.
First, Alice ``deletes'' the variable by detaching it from the sum.
Then, she relocates the detached variable to the left operand of the product.
Alice now sees the new product in place of the conflict ($\ePlus{}{1}{\eTimes{}{x}{\hole}}$).
However, Bob's edit to the variable is not lost.
After the remaining edits are shared,
both Alice and Bob see the new product and the renamed variable ($\ePlus{}{1}{\eTimes{}{y}{\hole}}$).

% restoration / multiparents
Alice and Bob both decide independently to move the variable to the right side of the product.
They place their cursors on the variable and delete it.
Alice relocates the detached variable to the right side of the product.
Bob changes his mind and puts it back on the left side.
They receive each other's edits and see a reference ($\multiVertex{\e_1}$), associated with the moving variable, on either side of the product ($\ePlus{}{1}{\eTimes{}{\multiVertex{\e_1}}{\multiVertex{\e_1}}}$).

% unicycles
After further discussion, Alice and Bob decide to try a different approach.
Alice deletes the references while Bob deletes the number and constructs another product in its place.
They receive each other's edits and see a sum of products of empty holes ($\hole * \hole + \hole * \hole$).
Alice decides to wrap the left product with the right one.
She deletes the left product and relocates it to the left side of the right product ($\ePlus{}{\hole}{\eTimes{}{\eTimes{}{\hole}{\hole}}{\hole}}$).
Before receiving Alice's edits,
Bob decides to wrap the right product with the left one.
He deletes the right product and relocates it to the right side of the left product ($\ePlus{}{\eTimes{}{\hole}{\eTimes{}{\hole}{\hole}}}{\hole}$).
Alice and Bob see two slightly different arithmetic forms built around the sum.
However, after they receive each other's edits, both products are detached from the sum ($\ePlus{}{\hole}{\hole}$).
One product has a reference to the other on its left ($\eTimes{}{\cycleVertex{\e_2}}{\hole}$).
The other has a reference on its right ($\eTimes{}{\hole}{\cycleVertex{\e_3}}$).
Together, they form a cycle.

% Modeling a program as a graph with a distinguished root allows us to handle interesting states like the ones in our examples.
% Such a graph can be decomposed into a \emph{grove} consisting of three sets:
%   terms corresponding to vertices with no parents,
%   terms corresponding to vertices with multiple parents,
%   and terms corresponding to vertices on unicyclic subgraphs.
% The main program corresponds to the descendants of the root.
% Deleted terms correspond to any other vertices with no parents.
% Terms restored more than once correspond to vertices with multiple parents.
% Whatever remains corresponds to vertices on unicyclic subgraphs.
% Conflicts correspond to vertices that share a parent.



% (Make it example driven: Alice and Bob. Be careful not to plagiarize Michael.)

% (simple cases, conflicts, why we need a graph ~> why groves are a thing)

% We (cyrus: need to) model a program as a graph (which allows us to handle interesting subtleties).
% This allows us to model tricky program states with holes and references.

% (neat idea: we represent conflicts as holes)

% Each user has a copy of the graph.
% A user can update all of the others with a ``sync'' action that coordinates propagation via an edit action calculus. 
% Actions in the calculus are commutative, so all users will converge on the same state as edits are synchronized.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Results and Contributions}

Results: commutativity theorem
Contribution: clean collaborative editing (via the commutativity theorem)

(Next steps (maybe): looking forward to semantic structure editing)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Related Work}

(Syntactic) Structure Editing (Scratch, ...)

% These properties (commutativity and graph representation) are unique to Grove.

Semantic Structure Editing (Hazel)

Collaborative Editing?

CRDT-style coordination (as opposed to operational transforms)
- similar to our approach b.c. of commutativity results, but our is unique b.c. of structure editing (vs text editing)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion}

Connect the results with collaborative structure editing: we (can now / should be able to) get the same kind of functionality as collaborative text editing in a structured setting. 
This paper reimagines some of it around communicating structure edits, as opposed to communicating line- or character-level text edits.
We leave this for future work.
% convey any excitement about the future here, not before

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% figures: grammars and graph diagrams like in section 2

\begin{figure}
  \[
    \arraycolsep=0pt
    \begin{array}{lcllll}
      t & {}\in{} & Term & {}::={} &
        e
        \mid \tau
        \mid q
      \\
      e & {}\in{} & Exp & {}::={} &
        \eVar{G}{x}
        \mid \eFun{G}{q}{\tau}{e}
        \mid \eApp{G}{e}{e}
        \mid \eNum{G}{n}
        \mid \ePlus{G}{e}{e}
        \mid \eTimes{G}{e}{e}
        \mid \multiVertex{\e}
        \mid \cycleVertex{\e}
        \mid \conflictHole{e_i}_{i \leq n}
        \mid \emptyHole{v}{p}
      \\
      \tau & {}\in{} & Typ & {}::={} &
        \tArrow{G}{\tau}{\tau}
        \mid \tNum{G}
        \mid \multiVertex{\e}
        \mid \cycleVertex{\e}
        \mid \conflictHole{\tau_i}_{i \leq n}
        \mid \emptyHole{v}{p}
      \\
      q & {}\in{} & Pat{} & {}::={} &
        \pVar{G}{x}
        \mid \multiVertex{\e}
        \mid \cycleVertex{\e}
        \mid \conflictHole{q_i}_{i \leq n}
        \mid \emptyHole{v}{p}
      \\
    \end{array}
  \]  
  \caption{Term syntax}
  \label{fig:Term syntax}
\end{figure}%

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{Grove}

\end{document}