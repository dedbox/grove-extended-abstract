\documentclass[nonacm, acmsmall, screen, review]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

\usepackage{stmaryrd}

\newcommand{\e}{\varepsilon}

\newcommand{\id}[1]{\textcolor{gray}{\ensuremath{#1}}}
\newcommand{\eid}[2]{{#2}^{\id{#1}}}

\newcommand{\hole}{\ensuremath{\square}} %\textcolor{violet}{\llparenthesis}}\textcolor{violet}{\rrparenthesis}}
\newcommand{\conflictHole}[1]{%
{\noexpandarg\StrSubstitute{#1}{,}{\textcolor{red}{\,\textbf{|}\,}}[\myargs]%
{\textcolor{red}{\textbf{\{}}\myargs\textcolor{red}{\textbf{\}}}}}}%
\newcommand{\emptyHole}[2]{\square_{\id{(#1, #2)}}}

\newcommand{\eVar}[2]{\eid{#1}{#2}}
\newcommand{\eFun}[4]{\eid{#1}{\lambda} #2 : #3 . #4}
\newcommand{\eApp}[3]{\eid{#1}{\left(#2~#3\right)}}
\newcommand{\eNum}[2]{\eid{#1}{\underline{#2}}}
\newcommand{\ePlus}[3]{#2~\eid{#1}{\texttt{+}}~#3}
\newcommand{\eTimes}[3]{#2~\eid{#1}{\texttt{*}}~#3}
\newcommand{\pVar}[2]{\eid{#1}{#2}}
\newcommand{\tArrow}[3]{#2 \eid{#1}{\rightarrow} #3}
\newcommand{\tNum}[1]{\eid{#1}{Num}}

\newcommand{\multiVertex}[1]{\textcolor{red}{\ensuremath{\curlyveedownarrow_{#1}}}}
\newcommand{\cycleVertex}[1]{\textcolor{red}{\ensuremath{\circlearrowleft_{#1}}}}

\newcommand{\E}{\mathcal{E}}

\newcommand{\SetOf}[1]{\left\{#1\right\}}

% tikz

\usepackage{tikz}
\usetikzlibrary{babel} % Ensure compatibility the 'babel' package

% Define outline versions of + and -
\def\outlinepad{0.4pt}
\def\outlinestroke{0.4pt}
\newcommand{\Plus}{\mathord{
\begin{tikzpicture}[anchor=base, baseline]
%\node at (0,0) {+};
\path[draw, line width=\outlinestroke]
   ( 0.333em+\outlinestroke/2+\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --( 0.333em+\outlinestroke/2+\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --( 0.021em+\outlinestroke/2+\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --( 0.021em+\outlinestroke/2+\outlinepad, -0.084em-\outlinestroke/2-\outlinepad)
 --(-0.020em-\outlinestroke/2-\outlinepad, -0.084em-\outlinestroke/2-\outlinepad)
 --(-0.020em-\outlinestroke/2-\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --(-0.333em-\outlinestroke/2-\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --(-0.333em-\outlinestroke/2-\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --(-0.020em-\outlinestroke/2-\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --(-0.020em-\outlinestroke/2-\outlinepad,  0.583em+\outlinestroke/2+\outlinepad)
 --( 0.021em+\outlinestroke/2+\outlinepad,  0.583em+\outlinestroke/2+\outlinepad)
 --( 0.021em+\outlinestroke/2+\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --cycle
 ;
\end{tikzpicture}
}}

\newcommand{\Minus}{\mathord{
\begin{tikzpicture}[anchor=base, baseline]
%\node at (0,0) {$-$};
\path[draw, line width=\outlinestroke]
   ( 0.306em+\outlinestroke/2+\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --( 0.306em+\outlinestroke/2+\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --(-0.306em-\outlinestroke/2-\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --(-0.306em-\outlinestroke/2-\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --cycle
 ;
\end{tikzpicture}
}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title[Grove]{Grove: A Convergent Collaborative Structure Editor Calculus}

% \author{Michael D. Adams}
% \orcid{0000-0003-3160-6972}

\author{Eric Griffis}
\orcid{0000-0003-1693-6172}

% \author{Cyrus Omar}
% \orcid{0000-0003-4502-7971}
\affiliation{
  %\position{Assistant Research Scientist}
  \department[0]{Computer Science and Engineering}
  \department[1]{Electrical Engineering and Computer Science}
  \department[2]{College of Engineering}
  \institution{University of Michigan}
  \streetaddress{Bob and Betty Beyster Building, 2260 Hayward Street}
  \city{Ann Arbor}
  \state{MI}
  \postcode{48109-2121}
  \country{USA}
}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO: name-check Hazel and Scratch and MPS (and WebFlow)

\section{Introduction}
\label{sec:introduction}

% (avoid creating a fight in the intro by claiming things the reader may summarily reject)

% (Cyrus: We use version control systems and we even use live share)
Programming is increasingly collaborative.
Programmers use a variety of tools, ranging from batch version control systems like Git~\cite{chacon_pro_2014} to real time collaboration tools such as Live Share~\cite{noauthor_use_nodate}, to coordinate changes to a common code base.

% (introduce structure editing)
% (Cyrus: in recent years, structure editing has been an active research area... talk about Hazel, Scratch, MPS, etc.
These collaboration tools largely assume that programs are edited as text.
However, structure editing has become increasingly prominent in both research and practice in recent years with tools like 
Scratch~\cite{resnick_scratch_2009}, 
MPS~\cite{voelter_language_2011}, 
Hazel~\cite{omar_hazelnut_2017}, 
WebFlow~\cite{noauthor_webflow_nodate},
and others.
%%% Make it clear this is something our community should care about
Structure editing makes (syntactically or semantically) invalid programs impossible to represent, which promises to simplifies the editing process for programmers at every skill level.

Existing collaboration techniques underlying tools such at Git or Live Share are text based.
Text editing involves linear edits, e.g., line or character insertions and deletions.
Structure editing, in contrast, involves tree edits, e.g., node insertions, deletions, and repositionings.
It is not clear how to generalize collaborative techniques rooted in text editing to a structured setting.
Our goal is to develop collaborative techniques that are rooted in structure editing.

% (Cyrus: Why is this a hard problem? All our existing tools are text based and it isn't clear how to do that correctly in a structured setting.)
In this paper, we introduce Grove, a \emph{collaborative structure editor calculus} based on Hazelnut~\cite{omar_hazelnut_2017}, a single-user structure editor calculus.
% (Introduce Grove: what makes it collaborative? what interesting thingG
In Grove, edits are commutative, i.e., they can be applied in any order, so collaboration is simply replay.
The shared edit state is represented as a graph, which is necessary to model interesting states that arise naturally in a collaborative setting, 
including direct conflicts and positioning conflicts. 
Users do not work with this graph directly---instead, the graph can be decomposed into a collection of syntax trees with references between them, which we call a \emph{grove}.
User actions on the grove can be converted into graph edits to be applied locally or sent to another user for replay.

% TODO: outline the rest of the paper

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Approach}
\label{sec:alice-and-bob}

% TODO: look for places to talk about the graph

% starting
Suppose Alice and Bob want to collaboratively edit a program using Grove.
For simplicity, we restrict ourselves to simple arithmetic expressions.
In Grove, Alice and Bob collaborate by sending each other their edit actions as graph edits.
We make no assumptions about the underlying communication infrastructure.

% sketch and share 
Alice and Bob open their respective editors to a new shared program,
which they see as a cursor on an empty hole ($\hole$).
Alice begins by constructing a number (1).
The new term fills the hole under the cursor.
Bob continues to see the hole until he receives Alice's edit,
at which point Bob also sees the number.

% wrapping
Bob builds on Alice's work by constructing a plus.
Structurally, this requires ``wrapping'' a plus constructor around the existing term, resulting in $\ePlus{}{1}{\hole}$.
Alice continues to see only the number until she receives Bob's edit,
at which point Alice also sees $\ePlus{}{1}{\hole}$.

% conflict
% TODO: Call out how this leads to a different result than if we replayed user actions instead of graph actions, i.e., emphasize the difference between text-based and structural edit conflicts. Make it clear that what's being said is "I want the left position of the + to be x or 2," as opposed to "I want to insert the character x or 2 at the given cursor position."

% Alice           Bob            
% 1 + >[]<        1 + >[]<         A: construct times; move to other child
% 1 + >[]< * []   1 + >[]<         B: construct x
% 1 + >[]< * []   1 + >x<          {sync: 
%                                     A: construct x 
%                                     B: construct times } 
% 1 + >x< * []    1 + >x< * []
% TODO: maybe allude to this kind of scenario in the related work

% Alice           Bob              
% 1 + >[]<        1 + >[]<         A: construct times
% 1 + >[]< * []   1 + >[]<         B: construct x
% 1 + >[]< * []   1 + >x<          {sync: 
%                                     A: construct x 
%                                     B: construct times } 
% 1 + >x< * []    1 + >x< * []

% Alice              Bob            
% 1 +^a >[]<         1 +^a >[]<       A: make R of a into times
% 1 +^a >[]< *^b []  1 +^a >[]<       B: make R of a into x
% 1 +^a >[]< *^b []  1 +^a >x<        {sync: 
%                                        A: make R of a into x
%                                        B: make R of a into times}

Both Alice and Bob move their cursors to the empty hole on the right.
Unfortunately, they have not yet agreed on what the next edit will be.
Alice constructs a times ($\eTimes{}{\hole}{\hole}$) whereas Bob constructs a variable ($x$).
They each send their edits to one another.
Because these edits occured concurrently, i.e., without any global relative ordering between them, we now have a conflict: is it a variable or a times?
This fact is explicitly represented as a conflict hole ($\ePlus{}{1}{\conflictHole{x, \eTimes{}{\hole}{\hole}}}$).

Conflict holes indicate where conflicts occur and specify the terms involved.
Transforming user actions into graph edits fixes the original location of the action, so subsequent replays are not affected by the cursor.
In contrast, naively applying the Hazel calculus (coincidentally and silently) merges the conflicting terms if neither Alice or Bob moves their cursor during replay, 
and causes their edit states to diverge otherwise.
Applying a text-based technique would likely merge the characters `x' and `*'.

% deletion / detach
% TODO: get rid of this, but keep the detail that Bob's edits aren't lost.
% Bob moves his cursor to the variable and renames it to $y$.
% Before Alice receives Bob's edit,
% she decides to resolve the conflict by wrapping Bob's variable in the product.
% First, Alice ``deletes'' the variable by detaching it from the sum.
% Then, she relocates the detached variable to the left operand of the product.
% Alice now sees the new product in place of the conflict ($\ePlus{}{1}{\eTimes{}{x}{\hole}}$).
% However, Bob's edit to the variable is not lost.
% After the remaining edits are shared,
% both Alice and Bob see the new product and the renamed variable ($\ePlus{}{1}{\eTimes{}{y}{\hole}}$).

% restoration / multiparents
Alice resolves the conflict by moving her cursor to the conflict hole and deleting it.
Bob receives her edits and they see $\ePlus{}{1}{\hole}$.
Alice moves the number to the right.
Bob does the same and then moves it back.
After they send their edits to each other, one term (the number) inhabits two positions, so we have a positioning conflict:
does the number go on the left or the right?
This fact is represented with two instances of a multiparent reference ($\multiVertex{\e_1})$,
a symbolic link to the conflicting term,
resulting in ($\ePlus{}{\multiVertex{\e_1}}{\multiVertex{\e_1}}$).

% unicycles
Alice and Bob decide to try a different approach.
Alice replaces each of the references with a times.
Bob receives Alice's edits, resulting in ($\hole * \hole + \hole * \hole$).
Alice moves the left times operator into the right one and sees ($\ePlus{}{\hole}{\eTimes{}{\eTimes{}{\hole}{\hole}}{\hole}}$).
Bob moves the right times operator into the left one and sees ($\ePlus{}{\eTimes{}{\hole}{\eTimes{}{\hole}{\hole}}}{\hole}$).
They share the edits with each other and both of the times operators disappear!

What happened?
From the perspective of the graph, each term has a corresponding vertex.
Moving a term corresponds to repositioning a vertex.
Repositioning a vertex involves deleting its incoming edges and reconstructing them somewhere else.
Although Alice and Bob separately deleted just the edge anchoring their respective times to the plus,
the combined edits detached both times operators and attached them to each other to
form a unicycle~\cite{kruskal_efficient_1990}:
two interdependent terms---%
($\eTimes{}{\cycleVertex{\e_2}}{\hole}$) and ($\eTimes{}{\cycleVertex{\e_3}}{\hole}$)%
---each carrying a symbolic reference to the other.

% Actions in the calculus are commutative, so all users will converge on the same state as edits are synchronized.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Formalism}
\label{sec:formalism}

We will now make the intuitions developed in the previous section more precise by defining a collaborative structure editor calculus called Grove.

\subsection{Editor States}

A \emph{graph} $G : \E \to \Sigma$ is a function from edges to edge states.
An \emph{edge} $\e{=}(u, v, p, v') \in \E$ is a directed link originating from source vertex $v$ at position $p$ and targeting vertex $v'$.
An \emph{edge state} $s \in \Sigma{=}\SetOf{\bot, \Plus, \Minus}$ indicates the presence and liveness of an edge in the graph.
When $G(\e) = \Plus$, we say $\e$ is live.
When $G(\e) = \Minus$, we say $\e$ is deleted.
Otherwise, we say there is no liveness indicator for $\e$ in $G$, or that $\e$ is not in $G$.
The total ordering $\bot \sqcup \Plus \sqcup \Minus$ forms a lattice over $\Sigma$.

Each vertex, except the distinguished root $v_{root}$, corresponds to a term constructor.
Each position, except the distinguished root $p_{root}$, corresponds to the location of a particular sort of subterm.
The \emph{arity} of a vertex is a set of pairs associating each valid position with a corresponding sort.
When the source positions and sorts of all of the vertices targeted by edges of $G$ are in the arity of their corresponding source vertices, we say $G$ is \emph{well sorted}.

For example, in section~\ref{sec:alice-and-bob}, we start with graphs with no edges in them.
When Alice constructs the number (1),
its constructor is represented by a new vertex $v_1$,
and a live edge $\e_1{=}(u_1, v_{root}, p_{root}, v_1)$ is added to $G$ so that $G(\e_1) = \Plus$.
Later, when the number is deleted, $G$ is updated so that $G(\e_1) = \Minus$.

A \emph{term} is an instance of one of the syntactic forms defined in figure~\ref{fig:syntax}.

Introduce the graph. Give an example connecting to Sec. 2.
Introduce terms and groves.
Outline how they're connected: what decomp / recomp are (don't overdo it)
(Inverse relationship)

\subsection{Edits}
What the graph edits are.
State the commutativity theorem (converging editor states when users communicate)
Point out that commutative calculus ==> this is a CRDT
User actions are higher level, but map onto graph edits: give an example
Show judgment form "user action --> graph edits" and give an example.

% Results: commutativity theorem
% Contribution: clean collaborative editing (via the commutativity theorem)

% (Next steps (maybe): looking forward to semantic structure editing)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Related Work}
\label{sec:related-work}

% Strategy:
% - "near" (conceptually or technically) work that helps understand what Grove is / does.
% - competing or contrasting work
% 
% Purpose:
% - establish novelty
% - entry points into related history

(Syntactic) Structure Editing (Scratch, ...)

% These properties (commutativity and graph representation) are unique to Grove.

Semantic Structure Editing (Hazel)

Collaborative Editing?

CRDT-style coordination (as opposed to operational transforms)
- similar to our approach b.c. of commutativity results, but ours is unique b.c. of structure editing (vs text editing)

formal version control systems?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion}
\label{sec:conclusion}

Connect the results with collaborative structure editing: we (can now / should be able to) get the same kind of functionality as collaborative text editing in a structured setting. 
This paper reimagines some of it around communicating structure edits, as opposed to communicating line- or character-level text edits.
We leave this for future work.
% convey any excitement about the future here, not before

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% figures: grammars and graph diagrams like in section 2

\begin{figure}
  \[
    \arraycolsep=0pt
    \begin{array}{lcllll}
      t & {}\in{} & Term & {}::={} &
        e
        \mid \tau
        \mid q
      \\
      e & {}\in{} & Exp & {}::={} &
        \eVar{G}{x}
        \mid \eFun{G}{q}{\tau}{e}
        \mid \eApp{G}{e}{e}
        \mid \eNum{G}{n}
        \mid \ePlus{G}{e}{e}
        \mid \eTimes{G}{e}{e}
        \mid \multiVertex{\e}
        \mid \cycleVertex{\e}
        \mid \conflictHole{e_i}_{i \leq n}
        \mid \emptyHole{v}{p}
      \\
      \tau & {}\in{} & Typ & {}::={} &
        \tArrow{G}{\tau}{\tau}
        \mid \tNum{G}
        \mid \multiVertex{\e}
        \mid \cycleVertex{\e}
        \mid \conflictHole{\tau_i}_{i \leq n}
        \mid \emptyHole{v}{p}
      \\
      q & {}\in{} & Pat{} & {}::={} &
        \pVar{G}{x}
        \mid \multiVertex{\e}
        \mid \cycleVertex{\e}
        \mid \conflictHole{q_i}_{i \leq n}
        \mid \emptyHole{v}{p}
      \\
    \end{array}
  \]  
  \caption{Term syntax}
  \label{fig:syntax}
\end{figure}%

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{Grove}

\end{document}